---
title: Queries
description: SELECT queries with filtering, ordering, grouping, and distinct
author: zoobzio
published: 2025-12-15
updated: 2025-12-15
tags:
  - Queries
  - SELECT
  - WHERE
  - ORDER BY
---

# Queries

Cereal provides two SELECT builders: `Select()` for single records and `Query()` for multiple. Both share the same filtering and ordering capabilities.

See [API Reference](../5.reference/1.api.md) for complete method signatures.

## Single Record Queries

`Select()` returns a single record or an error if not found:

```go
user, err := users.Select().
    Where("id", "=", "user_id").
    Exec(ctx, map[string]any{"user_id": 123})

if err != nil {
    // Includes "no rows found" when record doesn't exist
    return err
}
// user is guaranteed non-nil here
```

## Multi-Record Queries

`Query()` returns a slice:

```go
activeUsers, err := users.Query().
    Where("status", "=", "status").
    Exec(ctx, map[string]any{"status": "active"})

// Returns []*User, empty slice if no matches
```

## Field Selection

Select specific columns:

```go
// Only these fields populated
users.Select().Fields("id", "email", "name")
```

Unselected fields have zero values in the returned struct.

## WHERE Conditions

### Simple Conditions

```go
users.Query().Where("field", "operator", "param_name")
```

The parameter name maps to the params map at execution:

```go
users.Query().
    Where("age", ">=", "min_age").
    Where("status", "=", "status").
    Exec(ctx, map[string]any{
        "min_age": 18,
        "status":  "active",
    })
```

Multiple `Where()` calls produce AND:

```sql
WHERE age >= :min_age AND status = :status
```

### AND Groups

Explicit AND grouping:

```go
users.Query().WhereAnd(
    cereal.C("age", ">=", "min"),
    cereal.C("age", "<=", "max"),
    cereal.C("status", "=", "status"),
)
```

```sql
WHERE (age >= :min AND age <= :max AND status = :status)
```

### OR Groups

```go
users.Query().WhereOr(
    cereal.C("role", "=", "admin"),
    cereal.C("role", "=", "moderator"),
    cereal.C("role", "=", "editor"),
)
```

```sql
WHERE (role = :admin OR role = :moderator OR role = :editor)
```

### Combined Conditions

```go
users.Query().
    Where("active", "=", "is_active").
    WhereOr(
        cereal.C("role", "=", "admin"),
        cereal.C("role", "=", "mod"),
    )
```

```sql
WHERE active = :is_active AND (role = :admin OR role = :mod)
```

### NULL Checks

```go
// IS NULL
users.Query().WhereNull("deleted_at")

// IS NOT NULL
users.Query().WhereNotNull("verified_at")
```

### IN Operator

```go
users.Query().Where("status", "IN", "statuses")
// Execute with: {"statuses": []string{"active", "pending"}}
```

### Pattern Matching

```go
// LIKE (case-sensitive)
users.Query().Where("name", "LIKE", "pattern")
// {"pattern": "%alice%"}

// ILIKE (case-insensitive, PostgreSQL)
users.Query().Where("email", "ILIKE", "domain")
// {"domain": "%@example.com"}
```

### Array Operations

```go
// Contains
users.Query().Where("tags", "@>", "required_tags")
// {"required_tags": []string{"vip", "verified"}}

// Contained by
users.Query().Where("permissions", "<@", "allowed")

// Overlap
users.Query().Where("interests", "&&", "topics")
```

## ORDER BY

### Basic Ordering

```go
users.Query().OrderBy("created_at", "desc")
users.Query().OrderBy("name", "asc")
```

### Multiple Columns

```go
users.Query().
    OrderBy("status", "asc").
    OrderBy("created_at", "desc")
```

```sql
ORDER BY status ASC, created_at DESC
```

### NULL Handling

```go
// NULLs appear first
users.Query().OrderByNulls("score", "desc", "first")

// NULLs appear last
users.Query().OrderByNulls("score", "asc", "last")
```

### Expression Ordering

For computed values or pgvector:

```go
// Order by vector distance
users.Query().OrderByExpr("embedding", "<->", "query_vector", "asc")
```

## Pagination

```go
users.Query().
    OrderBy("created_at", "desc").
    Limit(20).
    Offset(40)  // Page 3, 20 per page
```

## DISTINCT

### Simple Distinct

```go
users.Query().Distinct()
```

### DISTINCT ON (PostgreSQL)

Get first row per distinct column combination:

```go
// First order per customer
orders.Query().
    DistinctOn("customer_id").
    OrderBy("customer_id", "asc").
    OrderBy("created_at", "desc")
```

```sql
SELECT DISTINCT ON (customer_id) * FROM orders
ORDER BY customer_id ASC, created_at DESC
```

## GROUP BY and HAVING

### Basic Grouping

```go
users.Query().
    Fields("status", "COUNT(*) as count").
    GroupBy("status")
```

### HAVING with Conditions

```go
users.Query().
    Fields("status", "COUNT(*) as count").
    GroupBy("status").
    Having("count", ">=", "min_count")
```

### Aggregate HAVING

```go
users.Query().
    Fields("department_id").
    GroupBy("department_id").
    HavingAgg("COUNT", "*", ">", "threshold")
```

```sql
HAVING COUNT(*) > :threshold
```

## Row Locking

For transactional consistency:

```go
// Exclusive lock - other transactions wait
user, err := users.Select().
    Where("id", "=", "id").
    ForUpdate().
    ExecTx(ctx, tx, params)

// Shared lock - allows other shared locks
users.Select().ForShare()

// Less restrictive locks
users.Select().ForNoKeyUpdate()
users.Select().ForKeyShare()
```

Lock modes:

| Method | Lock Type | Blocks |
|--------|-----------|--------|
| `ForUpdate()` | Exclusive | All other locks |
| `ForNoKeyUpdate()` | Exclusive (non-key) | FOR UPDATE, FOR NO KEY UPDATE |
| `ForShare()` | Shared | FOR UPDATE, FOR NO KEY UPDATE |
| `ForKeyShare()` | Key share | FOR UPDATE |

## Complete Example

```go
// Complex query with multiple features
results, err := users.Query().
    Fields("id", "name", "email", "score").
    Where("status", "=", "status").
    WhereNotNull("email").
    WhereOr(
        cereal.C("role", "=", "admin"),
        cereal.C("score", ">=", "threshold"),
    ).
    OrderByNulls("score", "desc", "last").
    OrderBy("name", "asc").
    Limit(50).
    Offset(0).
    Exec(ctx, map[string]any{
        "status":    "active",
        "admin":     "admin",
        "threshold": 100,
    })
```

```sql
SELECT id, name, email, score
FROM users
WHERE status = :status
  AND email IS NOT NULL
  AND (role = :admin OR score >= :threshold)
ORDER BY score DESC NULLS LAST, name ASC
LIMIT 50 OFFSET 0
```
