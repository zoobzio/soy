---
title: Mutations
description: INSERT, UPDATE, and DELETE operations with safety features
author: zoobzio
published: 2025-12-15
updated: 2025-12-15
tags:
  - Mutations
  - INSERT
  - UPDATE
  - DELETE
---

# Mutations

Soy provides three mutation builders: `Insert()`, `Modify()`, and `Remove()`. Each includes safety features to prevent common mistakes.

See [API Reference](../5.reference/1.api.md) for complete method signatures.

## INSERT Operations

### Basic Insert

```go
user := &User{
    Email: "alice@example.com",
    Name:  "Alice",
    Age:   30,
}

created, err := users.Insert().Exec(ctx, user)
// created has the database-generated ID
fmt.Println(created.ID)
```

INSERT automatically includes `RETURNING *` to populate generated columns.

### Batch Insert

```go
newUsers := []*User{
    {Email: "bob@example.com", Name: "Bob", Age: 25},
    {Email: "carol@example.com", Name: "Carol", Age: 35},
}

count, err := users.Insert().ExecBatch(ctx, newUsers)
// count is the number of records inserted (int64)
```

### ON CONFLICT - Do Nothing

Silently skip conflicts:

```go
user := &User{Email: "alice@example.com", Name: "Alice"}

created, err := users.Insert().
    OnConflict("email").
    DoNothing().
    Exec(ctx, user)

// created is nil if conflict occurred
```

### ON CONFLICT - Do Update (Upsert)

Update on conflict:

```go
user := &User{Email: "alice@example.com", Name: "Alice Updated", Age: 31}

upserted, err := users.Insert().
    OnConflict("email").
    DoUpdate().
    Set("name", "name").
    Set("age", "age").
    Build().
    Exec(ctx, user)
```

```sql
INSERT INTO users (email, name, age) VALUES (:email, :name, :age)
ON CONFLICT (email) DO UPDATE SET name = :name, age = :age
RETURNING *
```

### Multiple Conflict Columns

```go
users.Insert().
    OnConflict("tenant_id", "email").
    DoUpdate().
    Set("name", "name").
    Build()
```

## UPDATE Operations

### Basic Update

```go
updated, err := users.Modify().
    Set("name", "new_name").
    Set("age", "new_age").
    Where("id", "=", "user_id").
    Exec(ctx, map[string]any{
        "new_name": "Alice Smith",
        "new_age":  31,
        "user_id":  123,
    })
```

UPDATE returns the updated record via `RETURNING *`.

### Required WHERE

**UPDATE requires at least one WHERE condition.** This prevents accidental full-table updates:

```go
// Error: UPDATE requires WHERE clause
users.Modify().Set("status", "inactive").Exec(ctx, params)

// Correct
users.Modify().
    Set("status", "inactive").
    Where("id", "=", "user_id").
    Exec(ctx, params)
```

### Multiple Conditions

```go
users.Modify().
    Set("verified", "verified").
    Where("email", "=", "email").
    WhereNull("verified_at").
    Exec(ctx, map[string]any{
        "verified": true,
        "email":    "alice@example.com",
    })
```

### Batch Update

Update multiple records with different values:

```go
updates := []map[string]any{
    {"user_id": 1, "new_score": 100},
    {"user_id": 2, "new_score": 200},
    {"user_id": 3, "new_score": 300},
}

rowsAffected, err := users.Modify().
    Set("score", "new_score").
    Where("id", "=", "user_id").
    ExecBatch(ctx, updates)
```

## DELETE Operations

### Basic Delete

```go
rowsDeleted, err := users.Remove().
    Where("id", "=", "user_id").
    Exec(ctx, map[string]any{"user_id": 123})
```

DELETE returns the number of affected rows.

### Required WHERE

**DELETE requires at least one WHERE condition.** This prevents accidental table truncation:

```go
// Error: DELETE requires WHERE clause
users.Remove().Exec(ctx, nil)

// Correct
users.Remove().Where("status", "=", "status").Exec(ctx, map[string]any{"status": "deleted"})
```

### Multiple Conditions

```go
users.Remove().
    Where("status", "=", "status").
    Where("created_at", "<", "cutoff").
    Exec(ctx, map[string]any{
        "status": "inactive",
        "cutoff": time.Now().AddDate(0, -6, 0),
    })
```

### Batch Delete

Delete with different conditions per batch:

```go
deletions := []map[string]any{
    {"user_id": 1},
    {"user_id": 2},
    {"user_id": 3},
}

totalDeleted, err := users.Remove().
    Where("id", "=", "user_id").
    ExecBatch(ctx, deletions)
```

## Transactions

Execute mutations within transactions:

```go
tx, err := db.BeginTxx(ctx, nil)
if err != nil {
    return err
}
defer tx.Rollback()

// Insert order
order, err := orders.Insert().Build().ExecTx(ctx, tx, newOrder)
if err != nil {
    return err
}

// Insert order items
for _, item := range items {
    item.OrderID = order.ID
    _, err := orderItems.Insert().Build().ExecTx(ctx, tx, item)
    if err != nil {
        return err
    }
}

// Update inventory
_, err = inventory.Modify().
    Set("quantity", "new_qty").
    Where("product_id", "=", "product_id").
    ExecTx(ctx, tx, params)
if err != nil {
    return err
}

return tx.Commit()
```

## Error Handling

Mutations capture builder errors and report them at execution:

```go
result, err := users.Modify().
    Set("invalid_field", "value").  // Error captured
    Where("id", "=", "id").
    Exec(ctx, params)

// err: field "invalid_field" not in schema
```

## Inspecting SQL

Use `Render()` to see generated SQL:

```go
result, err := users.Modify().
    Set("name", "new_name").
    Where("id", "=", "user_id").
    Render()

fmt.Println(result.SQL)
// UPDATE users SET name = :new_name WHERE id = :user_id RETURNING *
```

## Complete Example

```go
// Upsert with transaction
func UpsertUser(ctx context.Context, db *sqlx.DB, user *User) (*User, error) {
    tx, err := db.BeginTxx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()

    // Try insert with conflict handling
    result, err := users.Insert().
        OnConflict("email").
        DoUpdate().
        Set("name", "name").
        Set("age", "age").
        Set("updated_at", "now").
        Build().
        ExecTx(ctx, tx, map[string]any{
            "email": user.Email,
            "name":  user.Name,
            "age":   user.Age,
            "now":   time.Now(),
        })
    if err != nil {
        return nil, err
    }

    // Log the change
    _, err = auditLogs.Insert().Build().ExecTx(ctx, tx, &AuditLog{
        UserID:    result.ID,
        Action:    "upsert",
        Timestamp: time.Now(),
    })
    if err != nil {
        return nil, err
    }

    if err := tx.Commit(); err != nil {
        return nil, err
    }

    return result, nil
}
```

## Dialect-Specific Behaviour

Different databases have varying levels of support for mutation features. Soy automatically adapts to each dialect's capabilities.

### Feature Support Matrix

| Feature | PostgreSQL | MariaDB | SQLite | MSSQL |
|---------|------------|---------|--------|-------|
| `ON CONFLICT` / Upsert | Native | `ON DUPLICATE KEY` | Native | Fallback* |
| `RETURNING` on INSERT | Yes | Yes | Yes | No |
| `RETURNING` on UPDATE | Yes | No** | Yes | No |
| `RETURNING` on DELETE | Yes | Yes | Yes | No |

\* MSSQL uses UPDATE-then-INSERT fallback for upsert operations.
\*\* MariaDB tracks [MDEV-5092](https://jira.mariadb.org/browse/MDEV-5092) for future support.

### MSSQL Upsert Fallback

MSSQL doesn't support `ON CONFLICT` syntax. When you use `OnConflict()` with MSSQL, Soy automatically:

1. Attempts an UPDATE using the conflict columns as WHERE conditions
2. If no rows are affected, performs an INSERT
3. Returns the resulting record via a SELECT

```go
// This works transparently across all dialects
result, err := users.Insert().
    OnConflict("email").
    DoUpdate().
    Set("name", "name").
    Build().
    Exec(ctx, user)
```

### MariaDB UPDATE Behaviour

MariaDB doesn't support `RETURNING` on UPDATE statements. When executing `Modify()`:

1. The UPDATE is executed without `RETURNING`
2. A follow-up SELECT retrieves the updated record using the WHERE conditions

This is handled automatically - your code remains the same across dialects.
