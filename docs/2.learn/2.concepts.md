---
title: Core Concepts
description: Queries, conditions, builders, and specs - the building blocks of cereal
author: zoobzio
published: 2025-12-15
updated: 2025-12-15
tags:
  - Concepts
  - Queries
  - Builders
  - Conditions
---

# Core Concepts

Cereal has four primitives: the cereal instance, query builders, conditions, and specs. Understanding these unlocks the full API.

## Cereal Instance

A `Cereal[T]` instance is the entry point for all queries. Create one per table:

```go
users, err := cereal.New[User](db, "users")
orders, err := cereal.New[Order](db, "orders")
```

The type parameter `T` flows through all operations, ensuring type safety:

```go
user, err := users.Select().Exec(ctx, params)   // Returns *User
order, err := orders.Select().Exec(ctx, params) // Returns *Order
```

**Create instances as package-level variables or singletons.** Each instance caches schema metadata. Dynamic creation leads to redundant reflection.

```go
// Good: fixed set of instances
var (
    Users  *cereal.Cereal[User]
    Orders *cereal.Cereal[Order]
)

func Init(db *sqlx.DB) error {
    var err error
    Users, err = cereal.New[User](db, "users")
    if err != nil {
        return err
    }
    Orders, err = cereal.New[Order](db, "orders")
    return err
}

// Bad: dynamic instance per request
func HandleRequest(userID string) {
    users, _ := cereal.New[User](db, "users") // Redundant reflection
    // ...
}
```

## Queries

### Select vs Query

Cereal provides two SELECT builders:

| Method | Returns | Use Case |
|--------|---------|----------|
| `Select()` | `*T` | Single record (uses LIMIT 1) |
| `Query()` | `[]*T` | Multiple records |

```go
// Single user by ID
user, err := users.Select().
    Where("id", "=", "user_id").
    Exec(ctx, map[string]any{"user_id": 123})

// All active users
activeUsers, err := users.Query().
    Where("status", "=", "status_param").
    Exec(ctx, map[string]any{"status_param": "active"})
```

### Field Selection

Select specific fields:

```go
// Only id and email
users.Select().Fields("id", "email")
```

Invalid field names produce errors at build time.

### Execution Methods

All builders provide:

| Method | Returns | Purpose |
|--------|---------|---------|
| `Exec(ctx, params)` | Result, error | Execute query |
| `ExecTx(ctx, tx, params)` | Result, error | Execute within transaction |
| `Render()` | *astql.QueryResult, error | Get generated SQL without executing |
| `MustRender()` | *astql.QueryResult | Panic on error (for tests/init) |

```go
// Inspect SQL before execution
result, err := users.Select().Where("id", "=", "id").Render()
fmt.Printf("SQL: %s\n", result.SQL)
// Output: SQL: SELECT id, email, name, age FROM users WHERE id = :id LIMIT 1
```

## Conditions

### Simple Conditions

WHERE clauses use three arguments: field, operator, parameter name.

```go
users.Select().Where("age", ">=", "min_age")
```

The parameter name maps to values in the `params` map:

```go
params := map[string]any{"min_age": 18}
user, err := users.Select().Where("age", ">=", "min_age").Exec(ctx, params)
```

### Supported Operators

| Category | Operators |
|----------|-----------|
| Comparison | `=`, `!=`, `>`, `>=`, `<`, `<=` |
| Pattern | `LIKE`, `NOT LIKE`, `ILIKE`, `NOT ILIKE` |
| Set | `IN`, `NOT IN` |
| Regex | `~`, `~*`, `!~`, `!~*` |
| Array | `@>`, `<@`, `&&` |
| Vector | `<->`, `<#>`, `<=>`, `<+>` |

### Condition Helpers

Use helpers for complex conditions:

```go
// Simple condition
C("field", "operator", "param")

// NULL checks
Null("field")     // field IS NULL
NotNull("field")  // field IS NOT NULL
```

### AND/OR Groups

Combine conditions:

```go
// AND group
users.Query().WhereAnd(
    cereal.C("age", ">=", "min_age"),
    cereal.C("status", "=", "status"),
)
// WHERE (age >= :min_age AND status = :status)

// OR group
users.Query().WhereOr(
    cereal.C("role", "=", "admin"),
    cereal.C("role", "=", "moderator"),
)
// WHERE (role = :admin OR role = :moderator)

// Combined
users.Query().
    WhereAnd(
        cereal.C("age", ">=", "min_age"),
        cereal.C("status", "=", "status"),
    ).
    WhereOr(
        cereal.C("role", "=", "admin"),
        cereal.C("role", "=", "mod"),
    )
// WHERE (age >= :min_age AND status = :status) AND (role = :admin OR role = :mod)
```

### NULL Conditions

```go
// IS NULL
users.Query().WhereNull("deleted_at")

// IS NOT NULL
users.Query().WhereNotNull("email")
```

## Ordering

### Basic Ordering

```go
users.Query().OrderBy("name", "asc")
users.Query().OrderBy("created_at", "desc")
```

### NULL Handling

Control where NULLs appear:

```go
// NULLs first
users.Query().OrderByNulls("score", "desc", "first")

// NULLs last
users.Query().OrderByNulls("score", "asc", "last")
```

### Expression Ordering

For pgvector similarity or custom expressions:

```go
// Order by vector distance
users.Query().OrderByExpr("embedding", "<->", "query_vec", "asc")
```

## Pagination

```go
users.Query().
    OrderBy("created_at", "desc").
    Limit(10).
    Offset(20)
```

## Builders

Each operation has a dedicated builder:

| Builder | Method | Purpose |
|---------|--------|---------|
| `Select[T]` | `Select()` | Single record queries |
| `Query[T]` | `Query()` | Multi-record queries |
| `Create[T]` | `Insert()` | INSERT operations |
| `Update[T]` | `Modify()` | UPDATE operations |
| `Delete[T]` | `Remove()` | DELETE operations |
| `Aggregate[T]` | `Count()`, `Sum()`, etc. | Aggregate functions |
| `Compound[T]` | Via `Query().Union()` | Set operations |

### Builder Pattern

Builders use method chaining with deferred execution:

```go
query := users.Query().
    Where("status", "=", "status").
    OrderBy("name", "asc").
    Limit(10)

// SQL not generated yet

results, err := query.Exec(ctx, params)
// SQL generated and executed
```

### Error Handling

Builders capture errors internally and report them at execution:

```go
query := users.Query().
    Where("invalid_field", "=", "param")  // Error captured here

results, err := query.Exec(ctx, params)   // Error returned here
// err: field "invalid_field" not in schema
```

This allows fluent chaining without checking errors at each step.

## Specs

Specs are JSON-serializable query definitions. Use them for:

- LLM-generated queries
- Configuration files
- API request bodies

```go
spec := cereal.QuerySpec{
    Fields: []string{"id", "email"},
    Where: []cereal.ConditionSpec{
        {Field: "age", Operator: ">=", Param: "min_age"},
    },
    OrderBy: []cereal.OrderBySpec{
        {Field: "name", Direction: "asc"},
    },
    Limit: intPtr(10),
}

query := users.QueryFromSpec(spec)
results, err := query.Exec(ctx, params)
```

See [Specs Guide](../3.guides/4.specs.md) for complete spec documentation.

## Transactions

Execute queries within transactions:

```go
tx, err := db.BeginTxx(ctx, nil)
if err != nil {
    return err
}
defer tx.Rollback()

user, err := users.Select().
    Where("id", "=", "user_id").
    ExecTx(ctx, tx, params)
if err != nil {
    return err
}

_, err = users.Modify().
    Set("login_count", "new_count").
    Where("id", "=", "user_id").
    ExecTx(ctx, tx, params)
if err != nil {
    return err
}

return tx.Commit()
```

## Row Locking

Lock rows for concurrent access:

```go
// Exclusive lock
users.Select().Where("id", "=", "id").ForUpdate()

// Shared lock
users.Select().Where("id", "=", "id").ForShare()

// Less restrictive locks
users.Select().Where("id", "=", "id").ForNoKeyUpdate()
users.Select().Where("id", "=", "id").ForKeyShare()
```
